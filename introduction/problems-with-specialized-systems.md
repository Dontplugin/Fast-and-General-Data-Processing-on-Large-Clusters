在过去几年里，我们已经看到计算系统的重大变化： 随着数据容量的日益增长越来越多的应用程序需要扩展到大型集群。在商业和科研领域，新的数据源和仪器正在产生数量快速增加的信息。
不幸的是，单一机器的处理和I/O能力并没有跟上这种节奏。最终,越来越多的组织需要通过扩展集群来进行计算。

集群环境同时给可编程性带来了挑战。第一是并行性：这个设置要用可捕捉广泛计算的编程模型以并行方式来重写应用程序。然而，不同于其他并行式平台，
集群的第二个挑战是故障：彻底的节点故障和零散节点(慢节点)很常见，逐渐形成规模并极大的影响应用程序的性能。最后一个挑战是，集群通常在多个用户之间共享，需要运行时间来进行动态地上下扩展计算，也加剧了干扰的可能性。

因此，广泛的新编程模型已经为集群而设计。起初，谷歌的MapReduce[36]发布了一个简单通用的模型，可以为批处理自动解决故障。
然而，人们发现MapReduce并不适用于其他类型的工作负载，导致广泛的和MapReduce具有显著不同的专有模型。例如，在谷歌，Pregel[72]为迭代图算法提供了
一个整体同步并行计算模型(BSP)；F1[95] 运行快，但不支持容错和SQL查询；MillWheel [2]支持连续流处理。谷歌以外，比如Storm [14], Impala [60], Piccolo [86] and GraphLab [71]
这些系统提供了相似的模型。随着新模型在每年中不断被实现，集群计算必然需要一系列针对不同任务的点解决方案。