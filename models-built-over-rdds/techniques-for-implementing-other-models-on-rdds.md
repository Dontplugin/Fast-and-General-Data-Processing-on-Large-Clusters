# 3.2 一些在`RDDs`上实现其他模型的技术

在特定的引擎上，不仅仅优化了数据上的运算符，也优化了数据的存储格式和数据的访问方式。例如，像`Shark`这样的`SQL`引擎可能会按列来处理数据，但是像`GraphX`这样的图引擎可能按
照索引来处理数据，使得效率最高。下面我们讨论几个常见的已经在`RDDs`上实现了那些优化的方法，这些方法使得可以在享受`RDD`模型带来的容错和组合等好处的同时，还能保持专业系统
的性能。

# 3.2.1 `RDDs` 中的数据格式

虽然`RDD`存储的是简单、扁平的数据记录，但我们发现一个实现更丰富的存储格式的有效策略是通过在同一条`RDD`记录中存储多个数据项，实现了每一条记录内的更加复杂的存储。用这
样的方式批处理即使几千条记录也足以非常接近专业的数据结构所带来的效率，同时仍把每个`RDD`“记录”的大小保持为几兆字节。

例如，在分析型数据库中，一种常用的优化就是列式存储和压缩。在`Shark`系统中，我们在一条`Spark`记录中存储多条数据库记录并运用这些优化。对 10000 到 100000 条记录压缩的程
度与将整个数据库按列格式存储后的压缩程度非常接近，使得我们仍然获得显著的效果。举一个比较高级的例子，`GraphX`【112】需要在代表图形的节点和边数据集中进行非常稀疏的连接(`JOIN`)操作。
它是这么操作的：在每个`RDD`的记录里存储包含多个图记录的哈希表，使得和新的数据进行连接（`JOIN`）时能够快速地查找到某个顶点和边。这点非常重要，因为在许多图算法中，
最后几次迭代只包含几条边或几个点，但它们仍然需要和整个数据集连接（`JOIN`）。同样的机制可以被用于更有效的来实现`Spark`的`Streaming`里的`updateStateByKey`(第4.3.3节)。

`RDD`模型有下面两个方面使得这个方法非常有效。

首先，`RDD`通常在内存中，因此对每个操作可以用指针来只读取整个“组合”记录中相关的部分。例如，一组用列表示的（整型，浮点型）记录可以用
一个整型数组和浮点数组来实现。如果我们只想读取整数字段，我们可以根据指针找到第一个数组而不用在内存中扫描第二个数组。同样地，在上述哈希表的`RDD`中，我们也
可以只查找所需要的记录。

其次，一个很自然的问题便是，如果每个计算模型都有自己的批处理记录的表示形式，我们如何有效地把要处理的类型结合起来？幸运的是，`RDD`底层接口是基于迭代器的（见 2.4 节中
的计算方法），这可以实现数据在不同格式中快速和流水线化地转换。一个含有复合记录的`RDD`可以通过`flatMap`批量操作有效地在解压的记录上返回一个迭代器，并且这个迭代器可以被
解压的记录上进一步的窄变换而进行流水线化，或者被重新打包成另一种格式进行转换，从而使未提交的且解压的数据量最小化。由于迭代器通常进行扫描操作，它们一般情况下是用于内存数据
的一个高效的接口。只要每个批记录能放在`CPU`缓存中，就使得数据能够快速地转换和转化。

# 3.2.2 数据分区

在专业模型中的第二个常见优化是在一个集群中用特定领域的方式对数据进行分区来提应用程序的性能。例如，`Pregel` 和 `HaLoop` 使用了一个可能的用户自定义函数来划分数据，从
而加快针对一个数据集的连接操作。并行数据库通常也提供了多种数据划分形式。

在`RDDs`里，对于每条记录都可以简单的通过`key`值实现数据分区。（事实上，这是`RDDs` 拥有的一条记录中的唯一标识）。请注意，即使`key`是对整个记录的，但含有多
个潜在数据项的“复合”记录仍然可以有一个有意义的`key`值。例如，在`GraphX` 中，每一个分区中的记录都有相同的哈希码来取分区数量的模，但是为了能够高效的查找仍然需要在内部进行
哈希。当系统使用复合记录来进行`shuffle`操作如`groupBy`时，,它们可以将每个突出的记录哈希为目标组合记录的`key`值。

最后一个有趣的分区用例是复合数据结构，数据结构的一些字段会随着时间被更新，有些则不。例如，在第 2.3.2 节的 `PageRank` 应用中，每一个`page`有两块数据：
一个不可变的 `links` 列表，和一个可变的 `rank`。我们用两个 `RDDs` 来表示，一个（`ID`,`links`）对和一个（`ID`，`ranks`）对，都是通过 `ID` 来进行划分的。系统优先将每个`ID`的 `ranks` 和 `links` 
记录都放置在相同机器上，但我们可以不改变 `links` 而分别对 `ranks` 进行更新。在 `GraphX`中，类似的技术被用来保存点和边的状态。

一般情况下，用户可以认为 `RDDs` 是一个在集群环境里更为具体的内存抽象。当在单台机器上使用内存时，程序员需要考虑数据的分布主要是为了优化查找和最大化地提高常访问的信息的集中式放置。
`RDDs` 通过让用户选择一个分区函数和划分的数据集，来提供对分布式内存的控制，但`RDDs` 避免了要求用户精确的指定每一个分区的位置。因此，运行时系统可以基于可用资源对分区数据进行有效地放置，
或在出现故障时移动分区数据，而程序员仍然可以控制访问的性能。

# 3.2.3 关于不可变性

`RDD` 模型与大多数专业系统的第三个区别是 `RDDs` 是不可变的。不可变性对于血统和错误恢复来说是很重要的，尽管它
与为这些目的而具有可变的数据集和记录版本号没有本质上的
不同。但是，可能有人会问这是否会导致性能低下。
虽然不可变性和容错性肯定会导致一些开销，但是我们发现这两项技术在很多情况下都能
够表现出良好的性能。
1. 我们用多个 co-partitioned RDDs 来表示复合数据结构，就像上一节里提到的 PageRank
例子一样，只允许程序修改需要修改部分的状态。在很多算法中，尽管记录的其他字段
在每次迭代中都会改变，但是有些字段是永远不变的，所以这种方式就可以取得了很好
的性能。
2. 当内部的数据结构是不可变的时候，即使在一条记录中，我们也可以用指针来重复使用
记录之前"版本"的状态。例如，在 Java 中字符串是不可变的，所以一个(Int, String)
记录上的映射（map） 如果保持 String 不变，只改变 Int 值的话，我们只需要使用一个
指向之前 String 对象指针，而不是去复制它。更笼统地说，在函数式编程中的持久化数
据结构[64]可以用其他形式的数据上的增量更新(例如，散列表) 来表示之前版本的增量。
令人很愉快的是，许多函数式编程中的想法可以直接帮助 RDDs。

在今后的工作中，我们将继续寻求其他方式来跟踪多个版本的状态，从而接近可变状态系统的
性能。

# 3.2.4 Implementing Custom Transformations

最后，我们发现在一些应用中，使用低级的 RDD 接口实现自定义的依赖模式和转换是有用
的（2.4 节）。该接口非常简单，实现他们仅仅需要依赖于父 RDDs 的列表和为 RDD 的分区从父
RDDs 给定的迭代器里进行迭代计算的一个函数。在 Shark 和 GraphX 的第一版中，我们实现了
一些这样的自定义运算符，这导致了很多新的运算符也被加入到 Spark 中去。比如说，
mapPartitions，是我们实现的一个有用的运算符，在给定一个 RDD[T]和一个计算迭代器函数
（给定 Iterator[T]，计算出 Iterator[U]）的情况下，通过将这个函数作用到每一个分区上，
最后能返回一个 RDD[U]。这是非常接近于 RDDs 最低级的接口，允许在每个分区里执行非功能
性的操作（例如，使用可变状态）。在 Shark 的实现中同样包含 join 和 groupBy 的自定义版本，
这是为了取代内置的相应运算符的工作。但是，请注意即使是实现了自定义转换的应用，这些
应用依然能够自动地享受到 RDD 模型的容错、多租户和组合所带来的好处，并且使得开发将会
比独立系统更加简单。
