# 2.1　介绍

在本章，我们提出了弹性分布式数据集（`RDD`）抽象，论文的其他部分在它上面构建了一个通用的集群计算堆栈。`RDDs`扩展了由`MapReduce`【72】和
`Dryad `【61】引进的数据流编程模型，这是如今最广泛使用于大规模数据分析的模型。数据流系统是成功的，因为它们允许用户使用高级操作符来编写计算，
而不需要担心任务分配和容错。然而，随着集群负载的多样化，数据流系统在许多重要的应用程序包括迭代算法、交互查询和流式处理上面效率却不高。
这导致了广泛的专业框架为这些应用而开发【72,22, 71, 95, 60, 14, 2】。

我们观察到许多数据流模型并不适用的应用程序抖有一个共同的特点：它们都需要跨计算的高效的数据共享，我们的工作就是从这里开展的。例如，迭代算法，像
`PageRank`，`K-means`聚类或者逻辑回归，需要在相同的数据集上多次运行；交互式数据挖掘通常需要在数据的同一子集上运行多个特定查询；并且流媒体应用程序
需要维护和共享不同时间的状态。不幸的是，尽管数据流框架提供了大量的运算算子，它们缺乏高效的数据共享原语。在这些框架中，在这些运算之间（比如两个`MapReduce`任务）
共享数据的唯一途径是把它写入一个外部的稳定存储系统，如一个分布式文件系统。由于数据复制，磁盘`I/O`和序列化，这些主导着应用程序的执行，导致了大量管理费用的产生。

确实如此，我们在检查为这些新的应用程序而构建的专业框架时发现，它们大多数对数据共享进行优化。例如，`Pregel`是一个迭代图形运算的系统，可以把期间的状态保存在存储器中；
而`HaLoop`【22】是一个迭代的`MapReduce`系统，能够在各步骤中有效的保持数据分区。不幸的是，这些框架仅仅支持特定的一些计算模式（如一系列`MapReduce`任务的循环），
并且为这些模式执行隐式的数据共享。它们不提供通用的可重用抽象，比如让一个用户加载几个数据集到内存中，从而来运行特定的查询。

相反，我们提出了一种新的抽象叫做弹性分布式数据集（`RDDs`），使得用户可以直接控制数据共享。`RDDs`是容错的，并行式数据结构允许用户在磁盘或者内存中显式的存储数据，
控制其分区，并使用一组丰富的运算符来操作它。它们提供了一个简单高效的编程接口，能够捕获当前的专业模型和新的应用程序。

设计`RDDs`的主要挑战是设计一个能够提供高效容错能力的编程接口。现有的集群内存存储抽象，比如分布式共享内存【79】，键值存储【81】，数据库和`Piccolo`【86】，提供了一个基于
可变状态细粒度更新的接口（如表中的单元格）。有了这个接口，提供容错能力的唯一途径就是跨机器的数据复制或者跨机器的日志更新。对于数据密集的工作负载来说，这两种途径都是极其昂贵的，
因为它们需要在集群网络之间复制大量的数据，然而其带宽却远远低于`RAM`，从而会产生大量的存储开销。

跟这些系统相比，`RDDs`提供了一种基于粗粒度转换（如`map`、过滤和连接）的接口，可以对多个数据单元运用同样的操作。使得它们通过记录那些用来构建数据集的转换（血统）而不是实际的数据，来提供
高效的数据容错能力。如果一个`RDD`的分区丢失，`RDD`有足够的关于如何从其他`RDDs`来重新计算这个分区的信息。因此，丢失的数据是可以恢复的，通常相当快，并不需要大成本的复制。

尽管基于粗粒度转换的接口可能第一眼看来是有限的，`RDDs`却很适用于众多并行式应用程序，因为这些应用程序自然地把同样的操作运用于多个数据单元中。事实上，`RDDs`能够高效的表达众多集群编程模型，
这些模型迄今已经被用作独立的系统，包括`MapReduce`、`DryadLINQ`、`SQL`、`Pregel`和`HaLoop`和这些系统不能捕获到的新应用程序如交互式数据挖掘。我们相信，`RDDs`适应计算需求的能力，在以前只有通过引入新的框架
才能实现，是`RDD`抽象的力量的最可靠证据。

我们在一个正被`UC Berkeley`和几家公司用于研究和应用程序生成的`Spark`系统中实现了`RDDs`。`Spark`提供了一个方便的集成语言编程接口，类似于`Scala`编程语言中的`DryadLINQ`【115】。
此外，`Spark`能够用于从`Scala`解释器中交互地查询大的数据集。我们相信，`Spark`是第一个让通用的编程语言使用于交互式的集群内存数据挖掘的模型。

我们通过用户应用程序的微基准测试和测量来评估一下`RDDs`和`Spark`，表明`Spark`在迭代应用上比`Hadoop`快了高达80倍，把一个真实的数据分析报告速度提高了40倍，并且能够在5–7秒的延迟内交互的扫描
一个1 TB的数据集。最后，为了举例说明`RDDs`的通用性，我们在`Spark`之上实现了`Pregel` 和`HaLoop`编程模型，包含位置优化，采用相对较小的库（每个200行代码）。

本章首先概述了`RDDs`（2.2节）和`Spark`（2.3）。然后我们讨论了`RDDs`的内部代表（2.4节），我们的实现（2.5节）和实验性的结果（2.6节）。最后，我们讨论了`RDDs`是如何捕获几个现有的编程模型（2.7节），
调查了相关的工作（2.8节）和做出总结。

