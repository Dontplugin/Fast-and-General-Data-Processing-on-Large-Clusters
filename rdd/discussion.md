# 2.7　评价

虽然 RDD 的不可变性质和粗粒度变换特质，使得其编程接口看上去能力有限，但实际中我们发现它们能适应的应用种类广泛。具体来说，RDD 可以表达大量的集群编程模型，而这些模
型之前都是针对独立框架而提出。从而，RDD 使得用户 可以在一个程序中组合这些模型 (比如,先运行一个 MapReduce 操作来构建一个图，而后对该图调用 Pregel)，并在它们之间共享数据。
在本节中，我们将讨论 RDD 可以表达哪些编程模型，以及为什么它们被广泛应用(§2.7.1).另外，我们还将讨论RDD中lineage信息的另一个好处--它使得在这些模型之间的调试变得容易。(§2.7.3).

# 2.7.1 对现有编程模型的表达

RDD 可以高效的表现一些此前相对独立的集群编程模型。所谓“高效”，是指 RDD 不仅能得到与它们相同的输出结果，而且还囊括了对这些框架所进行的 优化 ，比如将特定的数据保持
在内存中、数据分区优化以降低网络通讯和高效率的故障恢复。可以用 RDD 表达的模型包括：MapReduce：这个模型可以由 SPARK 中的 flatMap 与 groupByKey 操作进行表达，而如果用到
combiner 时则可引入 reduceByKey 操作。
DryadLINQ：DryadLINQ 系统基于 Dryad 更通用的运行机制上，提供了比 MapReduce 更为丰富的
操作。但这些操作都是批处理操作，且 Spark 中都有相应的 RDD 变换操作与之对应（如 map，
groupByKey， join 等等）。
SQL：与 DryadLINQ 的表达类似，SQL 查询对数据集的操作是基于数据并行的，故它们也可通过
RDD 变换而实现。在 第三章 ，我们会描述 Shark 组件，它是 SQL 在 RDD 上的一种高效实现。
Pregel：谷歌的 Pregel[72] 是一个专门针对迭代图型应用的模型。这种模型初看之下与其他
系统面向集合的编程模型有很大的不同。在 Pregel 中，一个程序以一系列协调好的“superstep”
运行。
在每一个 superstep 里，图内的各节点都通过执行一个用户定义的函数来实现对自身状态
的更新和对图的拓扑结构的改变，并向其他节点发送包含它们在下一超步所需要的信息的消息。
该模型可以表达许多图形算法，包括最短路径，二分匹配，和 PageRank。
注意，在 Pregel 的每次迭代中，它是将相同的用户自定义函数运用到所有节点上。 这是
RDD可以表达Pregel模型的关键。具体来说，我们可以将各次迭代时的节点状态保存为一个RDD，
然后调用一个变换(flatMap)来执行用户自定义的函数，并生成上述消息所对应的 RDD。之后，
通过将该 RDD 和节点状态的 RDD 进行 Jion 操作，便可实现消息的交换。同样值得注意的是，RDD
同时也能提供如 Pregel 那样将节点状态保存在内存中、控制节点分区策略来减少网络通讯以及
出现故障时的部分恢复功能。我们在 Spark 上实现了一个 200-行的 Pregel 库，读者请参阅[118]
迭代式 MapReduce：近期所提出的系统，包括 HaLoop[22]和 Twister [37]， 提供了一种迭代
式的 MapReduce 模型。在该模型下用户可以指定系统运行一系列的 MapReduce 任务。 这些系
统可以保持每次迭代的数据分区一致性，其中 Twister 还可将讲数据保持在内存中。这些优化
都可轻松地用 RDD 来表达，HaLoop 模型的实现对应一个 200 行左右的库。

# 2.7.2 解释`RDD`的表达能力

为什么 RDD 能够表达这些不同的编程模型？原因就是 RDD 上的限制在许多并行应用程序中影响非常小。其原因在于，虽然 RDD 仅能通过批量变换来创建，但众多的并行程序本质上都是 对
多条记录执行相同的操作 ，而这点便使得它们易于表达。另外，RDD 的不变性也不会影响其表达，因为相同数据集的各个不同版本可以通过多个对应的 RDD 来表示。事实上，大多数当前的
MapReduce 应用所基于的文件系统，比如 HDFS，并不允许更新文件(译注:记录只能创建或删除，而不能修改)。在后续章节（3 和 5）中，我们会对 RDD 表达进行更为详细的阐述。
最后一个问题是，为什么之前的框架没有提供相同级别的通用性呢？我们认为，这是由于这些系统仅关注在 MapReduce 和 Dryad 所不擅长的特定问题上，比如迭代，而未能发现这些问
题的 均是因为缺乏对数据共享的抽象。

# 2.7.3 利用`RDD`来调试

RDD的最初始设计时能为容错进行确切的重算特性，该特性也方便了对其的调试。具体来说，通过记录在作业中创建的RDD的lineage，借助重算所依赖的的RDD分区，人们可以 (1)在后续中
重建这些RDD，同时对其进行交互式查询, (2) 在一个单进程调试器中从该作业里运行任意一个任务。不同于传统的针对一般分布式系统的重放（replay）调试器[51], 需要对多个节点记录
和推断出其事件的先后顺序，RDD只需要记录血谱图 9
因此基本上不会引入任何记录开销。我们现在就是基于这些概念进行Spark调试器的开发工作[118]。
