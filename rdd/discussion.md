# 2.7　评价

虽然`RDD`的不可变性和粗粒度变换特性，使得其编程接口看上去能力有限，但我们发现了它们能适应的应用种类很广泛。尤其是，`RDD`可以表达大量的集群编程模型，而这些模
型迄今都是针对独立框架而提出，从而`RDD`能使用户可以在一个程序中组合这些模型 (比如,先运行一个`MapReduce` 操作来构建一个图，而后对该图调用`Pregel`)，并在它们之间共享数据。
在本节中，我们将讨论`RDD`可以表达哪些编程模型，以及为什么它们被广泛应用(§2.7.1)。另外，我们还将讨论我们所探求`RDD`中血统信息的另一个好处--它使得这些模型之间的调试变得容易。(§2.7.3).

# 2.7.1 对现有编程模型的表达

`RDD`可以高效的表现此前大量作为独立系统的集群编程模型。所谓“高效”，是指`RDD`不仅能得到与它们相同的输出结果，而且还包括了对这些框架所进行的优化，比如将特定的数据存储
在内存中、数据分区优化以降低网络通讯和高效率的故障恢复。可以用`RDD`表达的模型包括：

－`MapReduce` ：这个模型可以由`Spark`中的`flatMap` 与`groupByKey` 操作进行表达，而如果用到`combiner` 时则可引入`reduceByKey` 操作。
－`DryadLINQ`：`DryadLINQ` 系统基于`Dryad` 更通用的运行时，提供了比 `MapReduce` 更为丰富的操作。但这些操作都是与`Spark` 中`RDD` 变换操作对应的批处理操作（如`map`，
`groupByKey`，`join` 等等）。
－`SQL`：与 `DryadLINQ` 的表达类似，`SQL` 查询对数据集的操作是基于数据并行的，故它们也可通过`RDD`变换来实现。在第三章，我们会描述`Shark`组件，它是`SQL` 在`RDD`上的一种高效实现。
－`Pregel`：谷歌的`Pregel`【72】是一个适用于迭代图型应用的专业模型。初看之下，这种模型与其他系统中面向集合的编程模型有着很大的不同。在`Pregel`中，一个程序以一系列协调好的“`superstep`”的方式来
运行。在每一个`superstep`里，图内的各节点通过执行一个用户定义的函数来实现对自身状态的更新和对图的拓扑结构的改变，并向其他节点发送消息以便下一个`superstep`使用。该模型可以表达许多图形算法，
包括最短路径，二分匹配，和`PageRank`。

在`Pregel` 的每次迭代中，它将相同的用户自定义函数运用到所有节点上，而这是`RDD`可以表达`Pregel`模型的关键。因此，我们可以将每次迭代时的节点状态保存在一个`RDD`，
然后调用一个变换(`flatMap`)来执行用户自定义的函数，并生成该消息所对应的`RDD`。之后，通过将该`RDD` 和节点状态进行 `join` 操作，便可实现消息的交换。同样重要的是，通过`RDD`
我们也能如 `Pregel` 那样将节点状态保存在内存中，控制节点分区策略来减少网络通讯以及出现故障时的部分恢复功能。我们在 `Spark` 上实现了一个 200-行的 `Pregel` 库，读者可以参看【118】。

迭代式`MapReduce`：近期所提出的一些系统，包括`HaLoop`【22】和`Twister`【37】， 提供了一种迭代式的`MapReduce` 模型。在该模型下用户可以指定系统运行一系列循环的`MapReduce`任务。 这些系
统可以保持每次迭代的数据分区一致性，其中`Twister`还可把数据保持在内存中。这些优化都可轻松地用`RDD`来表达，并且`HaLoop` 模型的实现对应一个 200 行左右的库。

# 2.7.2 解释`RDD`的表达能力

为什么`RDD`能够表达这些不同的编程模型？原因就是`RDD`的限制在许多并行应用程序中的影响非常小。尤其是，尽管`RDD`仅能通过批量变换来创建，然而众多的并行程序本质上都是对
多条记录执行相同的操作，而这点正使得它们易于表达。另外，`RDD` 的不变性也不会影响其表达，因为我们可以通过多个对应的`RDD` 来表示同一个数据集的各个不同版本。事实上，大多数当前的
`MapReduce`应用所基于的文件系统，比如`HDFS`，并不允许对文件的更新。在后续章节（3 和 5）中，我们会对`RDD`的表达进行更为详细的阐述。

最后一个问题是，为什么之前的框架没有提供同等水平的通用性呢？我们认为，这是由于这些系统仅探寻了`MapReduce`和`Dryad`所不擅长的特定问题比如迭代，而未能发现这些问
题的共同原因是因为缺乏对数据共享的抽象。

# 2.7.3 利用`RDD`来调试

`RDD`的最初始设计能为容错进行确切的重算，这个特性也方便了对其的调试。具体来说，通过记录在作业中创建的`RDD`的血统，然后重算其所依赖的的`RDD`分区，人们可以 (1)在后续中
重建这些`RDD`，同时允许用户对其进行交互式查询, (2) 在一个单进程调试器中重新运行该作业中的任意一个任务。不像传统的针对一般分布式系统的重放（`replay`）调试器【51】那样, 需要对多个节点记录
和推断出其事件的先后顺序，`RDD`只需要记录血统图，因此基本上不会增加任何记录开销。我们现在就是基于这些概念进行`Spark`调试器的开发工作【118】。
